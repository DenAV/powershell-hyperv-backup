<#PSScriptInfo

.VERSION 15.06.2022

.AUTHOR Denis Denk

#>

<#
    .SYNOPSIS
    Hyper-V Backup Utility - Flexible backup of Hyper-V Virtual Machines.

    .DESCRIPTION
    This script will create a full backup of virtual machines, complete with configuration, snapshots/checkpoints, and VHD files.
    This script should be run on a Hyper-V host and the Hyper-V PowerShell management modules should be installed.

    To send a log file via e-mail using ssl and an SMTP password you must generate an encrypted password file.
    The password file is unique to both the user and machine.
    To create the password file run this command as the user and on the machine that will use the file:

    $creds = Get-Credential
    $creds.Password | ConvertFrom-SecureString | Set-Content c:\foo\ps-script-pwd.txt

    .PARAMETER List
    Enter the path to a txt file with a list of Hyper-V VM names to backup.
    If this option is not configured, all running VMs will be backed up.

    .PARAMETER Wd
    The path to the working directory to use for the backup before copying it to the final backup directory.
    Use a directory on local fast media to improve performance.

    .PARAMETER Keep
    Instructs the utility to keep a specified number of days’ worth of backups.
    VM backups older than the number of days specified will be deleted.
    Every effort has been taken to only remove backup files or folders generated by this utility.

    .PARAMETER Sz
    Configure the utility to use 7-Zip to compress the VM backups.
    7-Zip must be installed in the default location ($env:ProgramFiles) if it is not found, Windows compression will be used as a fallback.
    
    .PARAMETER SzThreads
    Configure 7-Zip to use more threads. mmt1 [1 thread] - mmt8 [8 threads].
    Please note this switch is passed through to 7-Zip. See 7-Zip help for more information.

    .PARAMETER SzComp
    Configure 7-Zip's compression strength. mx1 [fast compression] - mx9 [ultra compression].
    Please note this switch is passed through to 7-Zip. See 7-Zip help for more information.

    .PARAMETER ShortDate
    Configure the script to use only the Year, Month and Day in backup filenames.

    .PARAMETER Subject
    The subject line for the e-mail log. Encapsulate with single or double quotes.
    If no subject is specified, the default of "Hyper-V Backup Utility Log" will be used.

    .PARAMETER SendTo
    The e-mail address the log should be sent to.

    .PARAMETER From
    The e-mail address the log should be sent from.

    .PARAMETER Smtp
    The DNS name or IP address of the SMTP server.

    .PARAMETER User
    The user account to authenticate to the SMTP server.

    .PARAMETER Pwd
    The txt file containing the encrypted password for SMTP authentication.

    .PARAMETER UseSsl
    Configures the utility to connect to the SMTP server using SSL.

    .EXAMPLE
    Hyper-V-Backup.ps1 -BackupTo \\nas\vms -List C:\scripts\vms.txt -Wd E:\temp -NoPerms -Keep 30
    -Compress -Sz -SzThreads mmt8 -SzComp mx5 -L C:\scripts\logs -Subject 'Server: Hyper-V Backup' -SendTo me@contoso.com
    -From hyperv@contoso.com -Smtp smtp.outlook.com -User user -Pwd C:\foo\pwd.txt -UseSsl

    This will shutdown, one at a time, all the VMs listed in the file located in C:\scripts\vms.txt
    and back up their files to \\nas\vms, using E:\temp as a working directory. A zip file for each
    VM folder will be created using 7-zip. 7-zip will use 8 threads and medium compression. Any
    backups older than 30 days will also be deleted. The log file will be output to C:\scripts\logs
    and sent via e-mail with a custom subject line.
#>

## Set up command line switches.
[CmdletBinding()]

Param(
    [alias("Except")] $ExceptList = 'C:\HyperV-Backup\Liste\vms_except.txt',
    [alias("VMs")] $VmList = $Null,  # \Liste\vms_0.txt
    [alias("Disk")] $DiskWorkDir = $Null,
    [alias("Keep")] $History = 1, # 1 Tagen für Cloud-Host
    [alias("Wd")] $WorkDir = $Null, # Local-Backup
    [alias("Backup")] $BackupDir = $Null,  # Remote-Backup
    [alias("SzThreads")] $SzThreadNo = 'mmt10',
    [alias("SzComp")] $SzCompL = 'mx1',
    [switch]$ShortDate,
    [switch]$Encrypt = $True,
    [switch]$DateTime = $False)

$Error.Clear()

## Set a variable for computer name of the Hyper-V server. Vs
$HPV_Host = $Env:ComputerName 
$Backup_Host = 'backup-01.example.com'

$pfad = 'C:\HyperV-Backup'

# for Compress-VM
$global:ArchivName = ''

# Logging
$LogPath = "$pfad\Logging"

# Für Email Body
$CountError = 0
$Job = "Backup job: Die Aufgabe, sichern VMs auf dem $HPV_Host"

# für SMTP-Server authentication
$SmtpServer = 'mail.example.com'
$SmtpPort = 587
$UseSsl = $True
# Auth Absender
$SmtpUser = 'monitoring@example.com'
$SmtpPwd = "$pfad\psw-storage.txt"

# Mail-Adresse
$MailFrom = $SmtpUser
$MailTo = 'cloud-support@example.com'
$MailSubject = $Null

##
## Standard export Function starts here.
##
Function Export-Standart-RunVM {
    param (
        [string]$VmName
    )

    $VmExportBackupT = Test-Path "$WorkDir\$VmName"

    If ($VmExportBackupT -eq $True) {
        Write-Log -LogFile $LogFile -Type Info -Evt "Attempting to delete old Backup-folder VM: $VmName"
        Remove-Item "$WorkDir\$VmName" -Recurse -Force
    }

    ## Do a regular export of the VMs.
    try {
     
        Write-Log -LogFile $LogFile -Type Info -Evt "Attempting to export VM: $VmName"
        
        $VmName | Export-VM -Path "$WorkDir" -ErrorAction 'Stop'
    }
    catch {
            Write-Log -LogFile $LogFile -Type Err -Evt $_.Exception.Message
    }
    
}
##
## Standard export Function ends here.
##

##
## Compress-VM Function starts here.
##

Function Compress-VM {
    param (
        [string]$VmName
    )

    Write-Log -LogFile $LogFile -Type Info -Evt "Compressing VM: $VmName backup using 7-Zip compression"

    If ($ShortDate) {
        $ShortDateT = Test-Path -Path ("$WorkDir\$VmName-$(Get-DateShort).*z*")

        If ($ShortDateT) {
            Write-Log -LogFile $LogFile -Type Info -Evt "File $VmName-$(Get-DateShort) already exists, appending number"
            $i = 1
            $ShortDateNN = ("$VmName-$(Get-DateShort)-{0:D3}" -f $i++)
            $ShortDateExistT = Test-Path -Path "$WorkDir\$ShortDateNN.*z*"

            If ($ShortDateExistT) {
                do {
                    $ShortDateNN = ("$VmName-$(Get-DateShort)-{0:D3}" -f $i++)
                    $ShortDateExistT = Test-Path -Path "$WorkDir\$ShortDateNN.*z*"
                } until ($ShortDateExistT -eq $false)
            }

            $ArchivName =  $ShortDateNN

        }
        $ArchivName = "$VmName-$(Get-DateShort)"
    }

    else {
        $ArchivName = "$VmName-$(Get-DateLong)"

    }

    ## Test for 7zip being installed.
    ## If it is, compress the backup folder, if it is not use Windows compression.

    $7zT = Test-Path "C:\Programme\7-Zip\7z.exe"
    If ($7zT -eq $True) {

        if ($Encrypt -and (Test-Path -Path $SmtpPwd)) {

            $SecurePassword = Get-Content $SmtpPwd | ConvertTo-SecureString
            $BSTR = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecurePassword)
            $PwdEncrypt = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
    
            & "C:\Programme\7-Zip\7z.exe" -$SzThreadNo -$SzCompL -bso0 a -t7z  -m0=LZMA2:d64k:fb32 -ms=8m -p"$PwdEncrypt" -mhe -- ("$WorkDir\$ArchivName") "$WorkDir\$VmName\*"
                
        } else {
            & "C:\Programme\7-Zip\7z.exe" -$SzThreadNo -$SzCompL -bso0 a -t7z  -m0=LZMA2:d64k:fb32 -ms=8m -- ("$WorkDir\$ArchivName") "$WorkDir\$VmName\*"
        }
    }
    ## Compressing Vm backup using Windows compression
    else {
        Add-Type -AssemblyName "system.io.compression.filesystem"
        [io.compression.zipfile]::CreateFromDirectory("$WorkDir\$VmName", ("$WorkDir\$ArchivName.zip"))
    }

    $global:ArchivName = $ArchivName
    ## Remove the VMs export folder.
    Get-ChildItem -Path $WorkDir -Filter "$VmName" -Directory | Remove-Item -Recurse -Force
}

##
## Compress-VM Function endet here.
##


##
## Copy-To-RemoteBackup Function startet here.
##

function Copy-To-RemoteBackup {
    param (
        [Parameter (Mandatory = $true)]
        [string] $FileName
     )
    
    ## Remote-Backup Verzeichnis
    # $BackupDir  = "\\backup-01.example.com\backup"
    if ($Null -eq $BackupDir) {
        $BackupDir  = "\\$($Backup_Host)\$($HPV_Host)"
    }

    ## Wenn den Backup-Host erreichbar ist.
    if ([System.IO.Directory]::Exists($BackupDir)) {
        
        # Remote-Backup Verzeichnis
        ## Set a variable the path the virtual machines should be backed up to.
        if ($DateTime) {
            $destDirPath = "$($BackupDir)\$(Get-DateShort)\$(Get-DateTime)"
        }
        else {
            $destDirPath = "$($BackupDir)\$(Get-DateShort)"
        }

        ## Set Fullname 
        $sourceDirPath = Get-ChildItem -Path $WorkDir -Filter "$FileName.*z*" -File | Select-Object -ExpandProperty FullName


        # If the specified client directory is absent, create a new directory of the same name
        if (![System.IO.Directory]::Exists($destDirPath)) {
        New-Item -Path $destDirPath -ItemType "directory" | Out-Null
        }

        try {
            Copy-Item -Path $sourceDirPath -Destination $destDirPath -PassThru
            Write-Log -LogFile $LogFile -Type Succ -Evt $sourceDirPath
        }
        catch {
            Write-Log -LogFile $LogFile -Type Err -Evt $_.Exception.Message
        }

    }
    else { 
        Write-Log -LogFile $LogFile -Type Err -Evt "$($Backup_Host) - ist nicht erreichbar" 
    }
}

##
## Copy-To-RemoteBackup Function endet here.
##

########################################
##          START the Skript          ##
########################################

## If logging is configured, start logging.
## If the log file already exists, clear it.
If ($LogPath) {
    $FileName = ("Hyper-V-Backup_{0:yyyy-MM-dd_HH-mm-ss}.log" -f (Get-Date))
    $LogFile = "$($LogPath)\$($FileName)"
    
    $LogPathFolderT = Test-Path -Path $LogPath
    
    If ($LogPathFolderT -eq $False) {
        New-Item $LogPath -ItemType Directory -Force | Out-Null
        Write-Log -Type Info -Evt "Logging directory $LogFile doesn't exist. Creating it."
    }
    else {
        # Bereinigung alter Logdatei
        try {
            Clear-Log-History -LogPath $LogPath -History $History -LogFile $LogFile -ErrorAction 'Stop'
        }
        catch {
            $_.Exception.Message | Add-Content -Path $LogFile -Encoding ASCII -Value "$(Get-Date -Format "yyyy-MM-dd HH:mm:ss") [ERROR] $_"
        }
    }

    $LogT = Test-Path -Path $LogFile

    If ($LogT) {
        Clear-Content -Path $LogFile
    } 

    Add-Content -Path $LogFile -Encoding ASCII -Value "$(Get-Date -Format "yyyy-MM-dd HH:mm:ss") [INFO] Log started"
}

# Prüfung Verzeichnis für Local-Backup
if (![System.IO.Directory]::Exists($DiskWorkDir)) {
    Write-Log -LogFile $LogFile -Type Err -Evt "Das Verzeichnis: $DiskWorkDir fuer Backup existiert nicht!"
}
## Verzeichnis existiert
else {
    # Local-Backup Verzeichnis
    ## Set a variable the path the virtual machines should be backed up to.
    if ($DateTime) {
        $WorkDir = "$DiskWorkDir\$(Get-DateShort)\$(Get-DateTime)"
    }
    else {
        $WorkDir = "$DiskWorkDir\$(Get-DateShort)"
    }

    ##
    ## Display the current config and log if configured.
    ##
    Write-Log -LogFile $LogFile -Type Conf -Evt "************ Running with the following config *************."
    Write-Log -LogFile $LogFile -Type Conf -Evt "This virtual host:.......$HPV_Host."

    ## If a VM list file is configured, get the content of the file.
    ## If a VM list file is not configured, just get the running VMs.
    if ($VmList) {
        $VmList = $pfad + $VmList
    }

    if ($VmList -and (Get-Content $VmList)) {
        $CheckVM = Get-Content $VmList
    }
    else {
        $CheckVM = Get-VM | Where-Object {$_.State -eq "Running"} | Select-Object -ExpandProperty Name
    }
    ## If a VM exception list file is configured, get the content of the file.
    If ($ExceptList -and (Get-Content $ExceptList)) {
        Write-Log -LogFile $LogFile  -Type Conf -Evt "VMs liegt im Ausnahme-Datei ..."
        if ($CheckVM) {
            $Vms = [System.Collections.ArrayList]::new()
            foreach ($VM in $CheckVM) {
                # Suchen VM in Ausnahmen
                $ausnamen_vm = (Get-Content $ExceptList).Contains($VM)

                if ($ausnamen_vm) {
                    Write-Log -LogFile $LogFile  -Type Conf -Evt "...............$($VM)"
                } 
                else { 
                    [void]$Vms.Add($VM) 
                }
            }        
        }
        else {
            Write-Log -LogFile $LogFile -Type Info -Evt "... Alle VMs sind ausgeschaltet"
        }
    } # END If ($ExceptList -and (Get-Content $ExceptList))
    else {
        $Vms = $CheckVM
    }

    ## Check to see if there are any running VMs.
    ## If there are no VMs, then do nothing.
    If ($Vms.count -ne 0) {
        ## If the user has not configured the working directory, set it as the backup directory.
        If ($Null -eq $SzThreadNo) {
            $SzThreadNo = "mmt1"
        }

        If ($Null -eq $SzCompL) {
            $SzCompL = "mx1"
        }

        If ($Null -eq $ShortDate) {
            $ShortDate = "$LongDate"
        }

        Write-Log -LogFile $LogFile -Type Conf -Evt "VMs to backup:...........: $($Vms.Count)"
    
        ForEach ($Vm in $Vms) {
            Write-Log -LogFile $LogFile -Type Conf -Evt ".........................$Vm"
        }

        Write-Log -LogFile $LogFile -Type Conf -Evt "Remote-Backup directory:........$Backup."
        Write-Log -LogFile $LogFile -Type Conf -Evt "Local-Working directory:.......$WorkDir."
    
        If ($Null -ne $History) {
            Write-Log -LogFile $LogFile -Type Conf -Evt "Backups to keep:.........$History days"
        }
        else {
            Write-Log -LogFile $LogFile -Type Conf -Evt "Backups to keep:.........No Config"
        }

        If ($Null -ne $LogPath) {
            Write-Log -LogFile $LogFile -Type Conf -Evt "Logs directory:..........$LogPath."
        }
        else {
            Write-Log -LogFile $LogFile -Type Conf -Evt "Logs directory:..........No Config"
        }
    
        If ($MailTo) {
            Write-Log -LogFile $LogFile -Type Conf -Evt "E-mail log to:...........$MailTo."
        }
        else {
            Write-Log -LogFile $LogFile -Type Conf -Evt "E-mail log to:...........No Config"
        }
    
        If ($MailFrom) {
            Write-Log -LogFile $LogFile -Type Conf -Evt "E-mail log from:.........$MailFrom."
        }
        else {
            Write-Log -LogFile $LogFile -Type Conf -Evt "E-mail log from:.........No Config"
        }
    
        If ($SmtpServer) {
            Write-Log -LogFile $LogFile -Type Conf -Evt "SMTP server:.............$SmtpServer."
        }
        else {
            Write-Log -LogFile $LogFile -Type Conf -Evt "SMTP server:.............No Config"
        }

        If ($SmtpPwd) {
            Write-Log -LogFile $LogFile -Type Conf -Evt "SMTP pwd file:...........$SmtpPwd."
        }
        else {
            Write-Log -LogFile $LogFile -Type Conf -Evt "SMTP pwd file:...........No Config"
        }

        Write-Log -LogFile $LogFile -Type Conf -Evt "-Sz switch:..............$Sz."
        Write-Log -LogFile $LogFile -Type Conf -Evt "7-zip threads:...........$SzThreadNo."
        Write-Log -LogFile $LogFile -Type Conf -Evt "7-zip compression:.......$SzCompL."
        Write-Log -LogFile $LogFile -Type Conf -Evt "**************************************************************"
        Write-Log -LogFile $LogFile -Type Info -Evt "Process started."
        ##
        ## Display current config ends here.
        ##
    
        #    
        ## delete old backup data
        #
        try {
            Remove-OldDate -DirPath $DiskWorkDir -keep $History -LogFile $LogFile -ErrorAction 'Stop'
        }
        catch{
            Write-Log -LogFile $LogFile -Type Err -Evt $_.Exception.Message
        }
    
        ##
        ## Standard export process starts here.
        ##

        ## If the -NoPerms switch is NOT set, for each VM check for the existence of a previous export.
        ## If it exists then delete it, otherwise the export will fail.

        ForEach ($Vm in $Vms) {
            try {
                Export-Standart-RunVM -VmName $Vm
            }
            catch {
                Write-Log -LogFile $LogFile -Type Err -Evt $_.Exception.Message
            }

            try {
                ## Run the configuration options on the above backup files and folders.
                Compress-VM -VmName $Vm
            }
            catch {
                Write-Log -LogFile $LogFile -Type Err -Evt $_.Exception.Message
            }

            try {
                Copy-To-RemoteBackup -FileName $global:ArchivName -ErrorAction 'Stop'
            }
            catch {
                Write-Log -LogFile $LogFile -Type Err -Evt $_.Exception.Message
            }
        }

        try {
            Start-7ZIP -ArchivName $FileName
        }
        catch {
            Write-Log -LogFile $LogFile -Type Err -Evt $_.Exception.Message
        }

    } # If ($Vms.count -ne 0)

    ## If there are no VMs running, then do nothing.
    else {
        Write-Log -LogFile $LogFile -Type Info -Evt "There are no VMs running to backup"
    }
} ## END Else: Verzeichnis existiert

Write-Log -LogFile $LogFile -Type Info -Evt "Process finished. Fehler waren: $CountError"

## If logging is configured then finish the log file.
If ($LogPath) {
    Add-Content -Path $LogFile -Encoding ASCII -Value "$(Get-Date -Format "yyyy-MM-dd HH:mm:ss") [INFO] Log finished"

    ## This whole block is for e-mail, if it is configured.
    If ($SmtpServer) {
        ## Default e-mail subject if none is configured.
        If ($Null -eq $MailSubject) {
            if ($CountError -eq 0) {
                $MailSubject = "[Success]:[$HPV_Host] Backup-VMs Hyper-V Log"
            }
            else {
                $MailSubject = "[Failed]:[$HPV_Host] Backup-VMs Hyper-V Log"
            }
        }

        ## Setting the contents of the log to be the e-mail body.
        $MailBody = Get-Content -Path $LogFile | Out-String

        ## If an smtp password is configured, get the username and password together for authentication.
        ## If an smtp password is not provided then send the e-mail without authentication and obviously no SSL.
        If ($SmtpPwd -and (Test-Path -Path $SmtpPwd)) {

            ## If -ssl switch is used, send the email with SSL.
            ## If it isn't then don't use SSL, but still authenticate with the credentials.
            If ($UseSsl) {
                try {
                    EmailSenden -user $SmtpUser -to $MailTo -from $MailFrom -Subject $MailSubject -Job $Job -Fail $CountError -SSL $UseSsl `
                                -Body $MailBody -LogFile $LogFile -SmtpServer $SmtpServer -SmtpPort $SmtpPort -ErrorAction 'Stop'
                }
                catch {
                    Write-Log -LogFile $LogFile -Type Err -Evt $_.Exception.Message
                }
            }
        }
        else {
            Write-Log -LogFile $LogFile -Type Err -Evt "File with password for email does not exist. Please create"
        }
    }
}

Remove-Variable -Name * -ErrorAction SilentlyContinue

## End