<#PSScriptInfo

.VERSION 15.06.2022

.AUTHOR Denis Denk

#>

<#
    .SYNOPSIS
    Backup Hyper-V - Flexible backup of Hyper-V Virtual Machines.

    .DESCRIPTION
    This script will create a full backup of virtual machines, complete with configuration, snapshots/checkpoints, and VHD files.
    This script should be run on a Hyper-V host and the Hyper-V PowerShell management modules should be installed.

    To send a log file via e-mail using ssl and an SMTP password you must generate an encrypted password file.
    The password file is unique to both the user and machine.
    To create the password file run this command as the user and on the machine that will use the file:

    $creds = Get-Credential
    $creds.Password | ConvertFrom-SecureString | Set-Content c:\foo\ps-script-pwd.txt

    .PARAMETER List
    Enter the path to a txt file with a list of Hyper-V VM names to backup.
    If this option is not configured, all running VMs will be backed up.

    .PARAMETER Wd
    The path to the working directory to use for the backup before copying it to the final backup directory.
    Use a directory on local fast media to improve performance.

    .PARAMETER Keep
    Instructs the utility to keep a specified number of days’ worth of backups.
    VM backups older than the number of days specified will be deleted.
    Every effort has been taken to only remove backup files or folders generated by this utility.

    .PARAMETER Sz
    Configure the utility to use 7-Zip to compress the VM backups.
    7-Zip must be installed in the default location ($env:ProgramFiles) if it is not found, Windows compression will be used as a fallback.
    
    .PARAMETER SzThreads
    Configure 7-Zip to use more threads. mmt1 [1 thread] - mmt8 [8 threads].
    Please note this switch is passed through to 7-Zip. See 7-Zip help for more information.

    .PARAMETER SzComp
    Configure 7-Zip's compression strength. mx1 [fast compression] - mx9 [ultra compression].
    Please note this switch is passed through to 7-Zip. See 7-Zip help for more information.

    .PARAMETER ShortDate
    Configure the script to use only the Year, Month and Day in backup filenames.

    .PARAMETER Subject
    The subject line for the e-mail log. Encapsulate with single or double quotes.
    If no subject is specified, the default of "Hyper-V Backup Utility Log" will be used.

    .PARAMETER SendTo
    The e-mail address the log should be sent to.

    .PARAMETER From
    The e-mail address the log should be sent from.

    .PARAMETER Smtp
    The DNS name or IP address of the SMTP server.

    .PARAMETER User
    The user account to authenticate to the SMTP server.

    .PARAMETER Pwd
    The txt file containing the encrypted password for SMTP authentication.

    .PARAMETER UseSsl
    Configures the utility to connect to the SMTP server using SSL.

    .EXAMPLE
    Hyper-V-Backup.ps1 -BackupTo \\nas\vms -List C:\scripts\vms.txt -Wd E:\temp -NoPerms -Keep 30
    -Compress -Sz -SzThreads mmt8 -SzComp mx5 -L C:\scripts\logs -Subject 'Server: Hyper-V Backup' -SendTo me@contoso.com
    -From hyperv@contoso.com -Smtp smtp.outlook.com -User user -Pwd C:\foo\pwd.txt -UseSsl

    This will shutdown, one at a time, all the VMs listed in the file located in C:\scripts\vms.txt
    and back up their files to \\nas\vms, using E:\temp as a working directory. A zip file for each
    VM folder will be created using 7-zip. 7-zip will use 8 threads and medium compression. Any
    backups older than 30 days will also be deleted. The log file will be output to C:\scripts\logs
    and sent via e-mail with a custom subject line.
#>

## Set up command line switches.
[CmdletBinding()]

Param(
    [alias("Except")] $ExceptList = $Null,  # \Liste\vms_except.txt',
    [alias("VMs")] $VmList = $Null,  # \Liste\vms_0.txt
    [alias("Disk")] $DiskWorkDir = $Null, # path for Local-Backup
    [alias("L_Keep")] $L_History = 1, # 1 Tagen für Local-Backup
    [alias("R_Keep")] $R_History = 3, # 1 Tagen für RemoteBackup
    [alias("Backup")] $BackupDir = $Null,  # path Remote-Backup
    [alias("SzThreads")] $SzThreadNo = 'mmt10',
    [alias("SzComp")] $SzCompL = 'mx1',
    [switch]$ShortDate = $False,
    [switch]$Encrypt = $True,
    [switch]$DateTime = $False
)

$Error.Clear()

## Set a variable for computer name of the Hyper-V server. Vs
$HPV_Host = $Env:ComputerName 

# Ordner, in dem das Script liegt ermitteln
$path = [System.IO.Path]::GetDirectoryName($myInvocation.MyCommand.Definition)


# Get Konfiguration
if (Test-Path "$($path)\backup-hpv.ini") {
    
    $conf_ini = "$($path)\backup-hpv.ini" | Get-IniFile

    $DiskWorkDir = $conf_ini.local.directory
    $BackupDir = $conf_ini.backup.directory
    
    $L_History = $conf_ini.local.history
    $R_History = $conf_ini.backup.history

    $VmList = $conf_ini.path.vms_list
    $ExceptList = $conf_ini.path.vms_except
}
#################################################

# Logging
$LogPath = "$path\Logging"

# Für Email Body
$CountError = 0
$Job = "Backup job: Die Aufgabe, sichern VMs auf dem $HPV_Host"

# für SMTP-Server authentication
$SmtpServer = 'mail.example.com'
$SmtpPort = 587
$UseSsl = $True
# Auth Absender
$SmtpUser = 'backup-server@example.com'
$SmtpPwd = "$path\pwd-storage.txt"

# Mail-Adresse
$MailFrom = $SmtpUser
$MailTo = 'monitoring@example.de'
$MailSubject = $Null

## Registry key
$Backup_Day = Get-DateShort
$registory_key = "HKLM:\SOFTWARE\Backup-HPV"

## ++++++++++++++++++++++++++++++ ##
## Funktion Start-Copy-Daten starts here.
#
Function Start-Copy_Daten {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory, ValueFromPipeline)] [string] $sourceDirPath, 
        [Parameter(Mandatory)] [string] $destDirPath,
        [switch]$Recurse = $False
     )
    process {
        Write-Log -LogFile $LogFile -Type Info -Evt "Datensicherung für $($sourceDirPath) gestartet."
        $copy_success = $False
        Set-ItemProperty -Path $registory_key -Name "Result Copy" -Value "Running" -Force | Out-Null
        
        # If the specified client directory is absent, create a new directory of the same name
        if (![System.IO.Directory]::Exists("$destDirPath")) {
            New-Item -Path $destDirPath -ItemType Directory | Out-Null
            Write-Log -LogFile $LogFile -Type Info -Evt "Ordner wurde hergestellt: $($destDirPath)"
        }

            # If source folder or files
        if ((Get-ItemProperty -Path $sourceDirPath).Attributes -eq 'Directory') {
            # copy folder
            if ($Recurse) {
                $folders = Get-ChildItem -Name -Path $sourceDirPath -Directory -Recurse -ErrorAction Ignore
            }

            $destDirPath | Get-Item | Get-ChildItem | Where-Object {!$_.PSIsContainer} |
                ForEach-Object {[string[]] $destFileNames += $_.PSChildName}

            # size is shmall
            $sourceDirPath | Get-Item | Get-ChildItem | 
                Where-Object {!$_.PSIsContainer -and $_.Length -lt 100MB -and !($_.Name -like "tmp_*")} |
                ForEach-Object {[string[]] $error_files += $_.PSChildName}

            if ($error_files) {
                $error_files | ForEach-Object {
                    $error_file_length = "$($sourceDirPath)\$_" | Get-Item | Select-Object -ExpandProperty Length
                    Write-Log -LogFile $LogFile -Type Err -Evt "$_ ... - ist zu klein $([string]::Format("{0:0.00} KB", $error_file_length/1KB))"
                }
            }
                
            $copy_files = $sourceDirPath | Get-Item | Get-ChildItem | 
                Where-Object {!$_.PSIsContainer -and !($_.Name -like "tmp_*") -and !($destFileNames -contains $_.PSChildName) -and !($error_files -contains $_.PSChildName) }
                
            if ($NULL -ne $copy_files) {

                $copy_files | ForEach-Object {
                    try {
                        $source_length = "$($sourceDirPath)\$_" | Get-Item | Select-Object -ExpandProperty Length
                        Write-Log -LogFile $LogFile -Type Info -Evt "Datei wird gesichert: $sourceDirPath\$_ ; Größe - $([string]::Format("{0:0.00} KB", $source_length/1KB))"

                        Copy-Item -Path "$($sourceDirPath)\$_" -Destination $destDirPath
                        $dest_length = "$($destDirPath)\$_" | Get-Item | Select-Object -ExpandProperty Length

                        if ($source_length -eq $dest_length) {
                            Write-Log -LogFile $LogFile -Type Succ -Evt "wurde erfolgreich $([string]::Format("{0:0.00} KB", $dest_length/1KB)) gesichert"
                            $copy_success = $True
                        }
                        else {
                            throw "ERROR ... $($sourceDirPath)\$_ wurde nicht richtig gesichert! Größe für Remote und Lokale Dateien sind nicht gleich."
                            $copy_success = $False
                        }
                    }
                    catch {
                        Write-Log -LogFile $LogFile -Type Err -Evt $_.Exception.Message
                        $copy_success = $False
                    }
                }
            }
            else { $copy_success = $True }
        }
        else { # copy file
            try {
                Copy-Item -Path $sourceDirPath -Destination $destDirPath -PassThru
                $copy_success = $True
            }
            catch {
                Write-Log -LogFile $LogFile -Type Err -Evt $_.Exception.Message
                $copy_success = $False
            }
        }
        # IF unterordner 
        if ($folders) {
            foreach ($i in $folders) {
                if (![System.IO.Directory]::Exists("$destDirPath\$i")) {
                    New-Item $destDirPath\$i -ItemType Directory | Out-Null
                }
                if ([System.IO.Directory]::GetFiles("$sourceDirPath\$i").Count) {
                    Start-Copy_Daten -sourceDirPath $sourceDirPath\$i -destDirPath $destDirPath\$i
                }
            }
        }

        # if has done
        if ($copy_success -and $Null -eq $error_files){
            Write-Log -LogFile $LogFile -Type Info -Evt "Ordner: $sourceDirPath wurde erfolgreich gesichert."
            Set-ItemProperty -Path $registory_key -Name "Result Copy" -Value "Success" -Force | Out-Null
        }
        else {
            Write-Log -LogFile $LogFile -Type Err -Evt "Ordner: $sourceDirPath wurde mit Fehler gesichert!"
            Set-ItemProperty -Path $registory_key -Name "Result Copy" -Value "Failure" -Force | Out-Null
        }
    } # END Process
} # END Function Start-Copy_Daten
## ============================== ##

## ++++++++++++++++++++++++++++++ ##
## Function Standard export starts here.
#
Function Export-Standart_RunVM {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory, ValueFromPipeline)] [string]$VmName
    )
    process {
        $export_succ = $False
        Set-ItemProperty -Path $registory_key -Name "Result Export" -Value "Running" -Force | Out-Null
        $VmExportBackupT = Test-Path "$WorkDir\$VmName"

        If ($VmExportBackupT -eq $True) {
            Write-Log -LogFile $LogFile -Type Info -Evt "Attempting to delete old Backup-folder VM: $VmName"
            Remove-Item "$WorkDir\$VmName" -Recurse -Force
        }

        ## Do a regular export of the VMs.
        try {
            Write-Log -LogFile $LogFile -Type Info -Evt "Attempting to export VM: $VmName"
            $VmName | Export-VM -Path "$WorkDir" -ErrorAction 'Stop'
            $export_succ = $True
        }
        catch {
                Write-Log -LogFile $LogFile -Type Err -Evt $_.Exception.Message
                $export_succ = $False
        }

        # if has done
        if ($export_succ){
            Write-Log -LogFile $LogFile -Type Succ -Evt "VM: $VmName wurde erfolgreich exportiert."
            Set-ItemProperty -Path $registory_key -Name "Result Export" -Value "Success" -Force | Out-Null
        }
        else {
            Write-Log -LogFile $LogFile -Type Err -Evt "VM: $sourceDirPath wurde mit Fehler exportiert!"
            Set-ItemProperty -Path $registory_key -Name "Result Export" -Value "Failure" -Force | Out-Null
        }
    }
} # END Function Standard export
## ============================== ##

## ++++++++++++++++++++++++++++++ ##
## Function Compress-VM  starts here.
#
Function Compress-VM {
    param (
        [string]$VmName
    )

    Write-Log -LogFile $LogFile -Type Info -Evt "Compressing VM: $VmName backup using 7-Zip compression"

    If ($ShortDate) {
        $ShortDateT = Test-Path -Path ("$WorkDir\$VmName-$(Get-DateShort).*z*")

        If ($ShortDateT) {
            Write-Log -LogFile $LogFile -Type Info -Evt "File $VmName-$(Get-DateShort) already exists, appending number"
            $i = 1
            $ShortDateNN = ("$VmName-$(Get-DateShort)-{0:D3}" -f $i++)
            $ShortDateExistT = Test-Path -Path "$WorkDir\$ShortDateNN.*z*"

            If ($ShortDateExistT) {
                do {
                    $ShortDateNN = ("$VmName-$(Get-DateShort)-{0:D3}" -f $i++)
                    $ShortDateExistT = Test-Path -Path "$WorkDir\$ShortDateNN.*z*"
                } until ($ShortDateExistT -eq $false)
            }

            $ArchivName =  $ShortDateNN

        }
        $tmp_ArchivName = "tmp_$($VmName)-$(Get-DateShort)"
        $ArchivName = "$VmName-$(Get-DateShort)"
    }
    else {
        $tmp_ArchivName = "tmp_$($VmName)-$(Get-DateLong)"
        $ArchivName = "$VmName-$(Get-DateLong)"
    }

    ## Test for 7zip being installed.
    ## If it is, compress the backup folder, if it is not use Windows compression.
    $path_7zip = "C:\Programme\7-Zip\7z.exe"
    
    If (Test-Path $path_7zip) {

        if ($Encrypt -and (Test-Path -Path $SmtpPwd)) {

            $SecurePassword = Get-Content $SmtpPwd | ConvertTo-SecureString
            $BSTR = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($SecurePassword)
            $PwdEncrypt = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)

            Set-ItemProperty -Path $registory_key -Name "Result Zippen" -Value "Running" -Force | Out-Null
            & $path_7zip -$SzThreadNo -$SzCompL -bso0 a -t7z  -m0=LZMA2:d64k:fb32 -ms=8m -p"$PwdEncrypt" -mhe -- ("$WorkDir\$tmp_ArchivName") "$WorkDir\$VmName\*"
                
        } else {
            Set-ItemProperty -Path $registory_key -Name "Result Zippen" -Value "Running" -Force | Out-Null
            & $path_7zip -$SzThreadNo -$SzCompL -bso0 a -t7z  -m0=LZMA2:d64k:fb32 -ms=8m -- ("$WorkDir\$tmp_ArchivName") "$WorkDir\$VmName\*"
        }
        
        ## Rename tmp_* 7Z-Dateien
        try {
            Get-ChildItem -Path $WorkDir -Filter "$tmp_ArchivName.7z" -File | Rename-Item -NewName "$ArchivName.7z"

            $zip_file_length = "$($WorkDir)\$ArchivName.7z" | Get-Item | Select-Object -ExpandProperty Length
            Write-Log -LogFile $LogFile -Type Succ -Evt "VM: $VmName wurde erfolgreich als $ArchivName.7z ($([string]::Format("{0:0.00} KB", $zip_file_length/1KB))) gezippt"
            
            Set-ItemProperty -Path $registory_key -Name "Result Zippen" -Value "Success" -Force | Out-Null
        }
        catch {
            Write-Log -LogFile $LogFile -Type Err -Evt $_.Exception.Message
            Set-ItemProperty -Path $registory_key -Name "Result Zippen" -Value "Failure" -Force | Out-Null
        }
        
    }
    ## Compressing Vm backup using Windows compression
    else {
        Add-Type -AssemblyName "system.io.compression.filesystem"
        [io.compression.zipfile]::CreateFromDirectory("$WorkDir\$VmName", ("$WorkDir\$tmp_ArchivName.zip"))

        ## Rename tmp_* ZIP-Dateien
        try{
            Set-ItemProperty -Path $registory_key -Name "Result Zippen" -Value "Running" -Force | Out-Null

            Get-ChildItem -Path $WorkDir -Filter "$tmp_ArchivName.zip" -File | Rename-Item -NewName "$ArchivName.zip"
            $zip_file_length = "$($WorkDir)\$ArchivName.zip" | Get-Item | Select-Object -ExpandProperty Length
            Write-Log -LogFile $LogFile -Type Succ -Evt "VM: $VmName wurde erfolgreich als $ArchivName.zip ($([string]::Format("{0:0.00} KB", $zip_file_length/1KB))) gezippt"
            Set-ItemProperty -Path $registory_key -Name "Result Zippen" -Value "Success" -Force | Out-Null
        }
        catch {
            Write-Log -LogFile $LogFile -Type Err -Evt $_.Exception.Message

            Set-ItemProperty -Path $registory_key -Name "Result Zippen" -Value "Failure" -Force | Out-Null
        }
    }
    
    
    ## Remove the VMs export folder.
    Get-ChildItem -Path $WorkDir -Filter "$VmName" -Directory | Remove-Item -Recurse -Force
} # END Function Compress-VM
## ============================== ##

########################################
##          START the Skript          ##
########################################

if (Test-Path $registory_key) {
    # Remove alle Value im HKLM:\SOFTWARE\Backup-HPV
    Get-Item -Path $registory_key | Select-Object -ExpandProperty Property | 
        ForEach-Object -Process { Remove-ItemProperty -Path $registory_key -Name $_}

    # "Date Backup-HPV" - "Datum", Datensicherung
    New-ItemProperty -Path $registory_key -Name "Date Backup-HPV" -Value $Backup_Day -PropertyType String -Force | Out-Null

    ## "Result Backup-HPV(1 part)" - "Running", "Succes" oder "Failure", Waren Fehler mit Export und Sicherung oder nicht.
    New-ItemProperty -Path $registory_key -Name "Result Backup-HPV" -Value "new" -PropertyType String -Force | Out-Null
    # "Backup-HPV finished" - "$True" oder "$False", komplett Datensicherung (export, zippen, copy) ist erledigt. 
    New-ItemProperty -Path $registory_key -Name "Finished Backup-HPV" -Value $False -PropertyType String -Force | Out-Null

    ## "Result Export" - "Succes" oder "Failure", Zeigt wie geht es mit Export VM, gibt es Fehler oder nicht.
    New-ItemProperty -Path $registory_key -Name "Result Export" -Value "-" -PropertyType String -Force | Out-Null
    # "Finished Export" - "$True" oder "$False", komplett Export VM ist erledigt.
    New-ItemProperty -Path $registory_key -Name "Finished Export" -Value $False -PropertyType String -Force | Out-Null

    ## "Result Zippen" - "Succes" oder "Failure", Zeigt wie geht es mit Zippen VM, gibt es Fehler oder nicht.
    New-ItemProperty -Path $registory_key -Name "Result Zippen" -Value "-" -PropertyType String -Force | Out-Null
    # "Finished Zippen" - "$True" oder "$False", komplett Zippen VM ist erledigt.
    New-ItemProperty -Path $registory_key -Name "Finished Zippen" -Value $False -PropertyType String -Force | Out-Null

    ## "Result Copy" - "Succes" oder "Failure", Zeigt wie geht es mit Sicherungen für Daten, gibt es Fehler oder nicht.
    New-ItemProperty -Path $registory_key -Name "Result Copy" -Value "-" -PropertyType String -Force | Out-Null
    # "Finished Copy" - "$True" oder "$False", komplett Zippen VM ist erledigt.
    New-ItemProperty -Path $registory_key -Name "Finished Copy" -Value $False -PropertyType String -Force | Out-Null
}
else {
    Write-Error "Existiert Path - HKLM:\SOFTWARE\Backup-HPV nicht"
    break
}

## If logging is configured, start logging.
## If the log file already exists, clear it.
If ($LogPath) {
    $FileName = ("Hyper-V-Backup_{0:yyyy-MM-dd_HH-mm-ss}.log" -f (Get-Date))
    $LogFile = "$($LogPath)\$($FileName)"
    
    $LogPathFolderT = Test-Path -Path $LogPath
    
    If ($LogPathFolderT -eq $False) {
        New-Item $LogPath -ItemType Directory -Force | Out-Null
        Write-Log -Type Info -Evt "Logging directory $LogFile doesn't exist. Creating it."
    }
    else {
        # Bereinigung alter Logdatei
        try {
            Clear-Log-History -LogPath $LogPath -History $R_History -LogFile $LogFile -ErrorAction 'Stop'
        }
        catch {
            $_.Exception.Message | Add-Content -Path $LogFile -Encoding ASCII -Value "$(Get-Date -Format "yyyy-MM-dd HH:mm:ss") [ERROR] $_"
        }
    }

    If (Test-Path -Path $LogFile) {
        Clear-Content -Path $LogFile
    } 

    Add-Content -Path $LogFile -Encoding ASCII -Value "$(Get-Date -Format "yyyy-MM-dd HH:mm:ss") [INFO] Log started"
}

# Prüfung Verzeichnis für Local-Backup
if (![System.IO.Directory]::Exists($DiskWorkDir)) {
    Write-Log -LogFile $LogFile -Type Err -Evt "Das Verzeichnis: $DiskWorkDir fuer Local-Backup existiert nicht!"
}
## Verzeichnis existiert
else {
    # Local-Backup Verzeichnis
    ## Set a variable the path the virtual machines should be backed up to.
    if ($DateTime) {
        $WorkDir = "$($DiskWorkDir)\$($Backup_Day)\$(Get-DateTime)"
        $Backup = "$($BackupDir)\$($Backup_Day)\$(Get-DateTime)"
    }
    else {
        $WorkDir = "$($DiskWorkDir)\$($Backup_Day)"
        $Backup = "$($BackupDir)\$($Backup_Day)"
    }

    ##
    ## Display the current config and log if configured.
    ##
    Set-ItemProperty -Path $registory_key -Name "Result Backup-HPV" -Value "Running" -Force | Out-Null

    Write-Log -LogFile $LogFile -Type Conf -Evt "************ Running with the following config *************."
    Write-Log -LogFile $LogFile -Type Conf -Evt "This virtual host:.......$HPV_Host."

    ## If a VM list file is configured, get the content of the file.
    ## If a VM list file is not configured, just get the running VMs.
    if ($VmList -and (Get-Content $VmList)) {
        $CheckVM = Get-Content $VmList
    }
    else {
        $CheckVM = Get-VM | Where-Object {$_.State -eq "Running"} | Select-Object -ExpandProperty Name
    }
    ## If a VM exception list file is configured, get the content of the file.
    If ($ExceptList -and (Get-Content $ExceptList)) {

        Write-Log -LogFile $LogFile  -Type Conf -Evt "VMs liegt im Ausnahme-Datei ..."
        if ($CheckVM) {
            $Vms = [System.Collections.ArrayList]::new()
            $CheckVM | ForEach-Object {
                # Suchen VM in Ausnahmen
                $ausnamen_vm = (Get-Content $ExceptList).Contains($_)

                if ($ausnamen_vm) {
                    Write-Log -LogFile $LogFile  -Type Conf -Evt "...............$($_)"
                } 
                else { 
                    [void]$Vms.Add($_) 
                }
            }        
        }
        else {
            Write-Log -LogFile $LogFile -Type Info -Evt "... Alle VMs sind ausgeschaltet"
        }

    } # END If ($ExceptList -and (Get-Content $ExceptList))
    else {
        $Vms = $CheckVM
    }

    ## Check to see if there are any running VMs.
    ## If there are no VMs, then do nothing.
    If ($Vms.count -ne 0) {
        ## If the user has not configured the working directory, set it as the backup directory.
        If ($Null -eq $SzThreadNo) {
            $SzThreadNo = "mmt1"
        }

        If ($Null -eq $SzCompL) {
            $SzCompL = "mx1"
        }

        Write-Log -LogFile $LogFile -Type Conf -Evt "VMs to backup:...........: $($Vms.Count)"
    
        ForEach ($Vm in $Vms) {
            Write-Log -LogFile $LogFile -Type Conf -Evt ".........................$Vm"
        }

        Write-Log -LogFile $LogFile -Type Conf -Evt "Remote-Backup directory:........$Backup."
        Write-Log -LogFile $LogFile -Type Conf -Evt "Local-Working directory:.......$WorkDir."
    
        If ($Null -ne $L_History) { Write-Log -LogFile $LogFile -Type Conf -Evt "Local Backups to keep:.........$L_History days" }
        else { Write-Log -LogFile $LogFile -Type Conf -Evt "Local Backups to keep:.........No Config" }
        
        If ($Null -ne $R_History) { Write-Log -LogFile $LogFile -Type Conf -Evt "Remote Backups to keep:.........$R_History days" }
        else { Write-Log -LogFile $LogFile -Type Conf -Evt "Remote Backups to keep:.........No Config" }

        If ($Null -ne $LogPath) { Write-Log -LogFile $LogFile -Type Conf -Evt "Logs directory:..........$LogPath." }
        else { Write-Log -LogFile $LogFile -Type Conf -Evt "Logs directory:..........No Config" }
    
        If ($MailTo) { Write-Log -LogFile $LogFile -Type Conf -Evt "E-mail log to:...........$MailTo." }
        else { Write-Log -LogFile $LogFile -Type Conf -Evt "E-mail log to:...........No Config" }
    
        If ($MailFrom) { Write-Log -LogFile $LogFile -Type Conf -Evt "E-mail log from:.........$MailFrom." }
        else { Write-Log -LogFile $LogFile -Type Conf -Evt "E-mail log from:.........No Config" }
    
        If ($SmtpServer) { Write-Log -LogFile $LogFile -Type Conf -Evt "SMTP server:.............$SmtpServer." }
        else { Write-Log -LogFile $LogFile -Type Conf -Evt "SMTP server:.............No Config" }

        If ($SmtpPwd) { Write-Log -LogFile $LogFile -Type Conf -Evt "SMTP pwd file:...........$SmtpPwd." }
        else { Write-Log -LogFile $LogFile -Type Conf -Evt "SMTP pwd file:...........No Config" }

        Write-Log -LogFile $LogFile -Type Conf -Evt "7-zip threads:...........$SzThreadNo."
        Write-Log -LogFile $LogFile -Type Conf -Evt "7-zip compression:.......$SzCompL."
        Write-Log -LogFile $LogFile -Type Conf -Evt "**************************************************************"
        Write-Log -LogFile $LogFile -Type Info -Evt "Process started."
        ##
        ## Display current config ends here.
        ##
    
        #    
        ## delete old local-backup data
        #
        try {
            Remove-OldDate -DirPath $DiskWorkDir -keep $L_History -LogFile $LogFile -ErrorAction 'Stop'
        }
        catch{
            Write-Log -LogFile $LogFile -Type Err -Evt $_.Exception.Message
        }
    
        ##
        ## Standard export process starts here.
        ##

        ## If the -NoPerms switch is NOT set, for each VM check for the existence of a previous export.
        ## If it exists then delete it, otherwise the export will fail.
        #
        $Vms | Get-VM | Where-Object {$_.State -eq "Running"} | Select-Object -ExpandProperty Name | Foreach-Object {
            $count_export = 0
            do {
                try {
                    ## Run Export
                    Set-ItemProperty -Path $registory_key -Name "Finished Export" -Value $False -Force | Out-Null
                    $_ | Export-Standart_RunVM
                    if((Get-ItemPropertyValue -Path $registory_key -Name "Result Export") -ne "Success" ) {
                        $count_export += 1
                        Write-Log -LogFile $LogFile -Type Err -Evt "Attempting to export VM:$count_export, Sleep 10"
                        Start-Sleep 10
                    }
                }
                catch {
                    Write-Log -LogFile $LogFile -Type Err -Evt "Attempting to export VM:$count_export, $($_.Exception.Message)"
                    $count_export += 1
                    Start-Sleep 10
                }
            # Condition that stops the loop if it returns true
            } until ( (Get-ItemPropertyValue -Path $registory_key -Name "Result Export" -ErrorAction Ignore) -eq "Success" `
                    -or $count_export -ge 3)
                
            try {
                ## Run Zippen VM.
                Set-ItemProperty -Path $registory_key -Name "Finished Zippen" -Value $False -Force | Out-Null
                Compress-VM -VmName $_
            }
            catch {
                Write-Log -LogFile $LogFile -Type Err -Evt $_.Exception.Message
            }

        }
        
        Set-ItemProperty -Path $registory_key -Name "Finished Export" -Value $True -Force | Out-Null
        Set-ItemProperty -Path $registory_key -Name "Finished Zippen" -Value $True -Force | Out-Null
        
        if ([System.IO.Directory]::Exists($BackupDir)){
            $count_copy = 0
            do {
                try {
                    ## Run the Copy
                    Set-ItemProperty -Path $registory_key -Name "Finished Copy" -Value $False -Force | Out-Null

                    Start-Copy_Daten -sourceDirPath $WorkDir -destDirPath $Backup -ErrorAction 'Stop'
                    if((Get-ItemPropertyValue -Path $registory_key -Name "Result Copy") -ne "Success" ) {
                        Write-Log -LogFile $LogFile -Type Err -Evt "Attempting to copy VM:$count_copy, Sleep 30"
                        $count_copy += 1
                        Start-Sleep 30
                    }
                }
                catch {
                    Write-Log -LogFile $LogFile -Type Err -Evt "Attempting to copy VM:$count_copy, $($_.Exception.Message), Sleep 30"
                    $count_copy += 1
                    Start-Sleep 30
                }
                # Condition that stops the loop if it returns true
            } until ( (Get-ItemPropertyValue -Path $registory_key -Name "Result Copy") -eq "Success" `
                    -or $count_copy -ge 3)
            
            #
            ## delete old remote-backup data
            #
            try {
                Remove-OldDate -DirPath $BackupDir -keep $R_History -LogFile $LogFile -ErrorAction 'Stop'
            }
            catch{
                Write-Log -LogFile $LogFile -Type Err -Evt $_.Exception.Message
            }
        }
        else {
            Write-Log -LogFile $LogFile -Type Err -Evt "Remote-Backup ist nicht erreichbar: $BackupDir"
        }
        Set-ItemProperty -Path $registory_key -Name "Finished Copy" -Value $True -Force | Out-Null
    } # If ($Vms.count -ne 0)

    ## If there are no VMs running, then do nothing.
    else {
        Write-Log -LogFile $LogFile -Type Info -Evt "There are no VMs running to backup"
    }
} ## END Else: Verzeichnis existiert

Write-Log -LogFile $LogFile -Type Info -Evt "Process finished. Fehler waren: $CountError"

## "Result Backup-HPV" ist "Success" oder "Failure"
if ((Get-ItemPropertyValue -Path $registory_key -Name "Result Export") -eq "Success" `
    -and (Get-ItemPropertyValue -Path $registory_key -Name "Result Zippen") -eq "Success" `
    -and (Get-ItemPropertyValue -Path $registory_key -Name "Result Copy") -eq "Success" `
    -and $CountError -le 0) {

    Set-ItemProperty -Path $registory_key -Name "Result Backup-HPV" -Value "Success" -Force | Out-Null
}
else {
    Set-ItemProperty -Path $registory_key -Name "Result Backup-HPV" -Value "Failure" -Force | Out-Null
}

## "Finished Backup-HPV" ist "Success" oder "Failure"
if ((Get-ItemPropertyValue -Path $registory_key -Name "Finished Export") -eq $True `
    -and (Get-ItemPropertyValue -Path $registory_key -Name "Finished Zippen") -eq $True `
    -and (Get-ItemPropertyValue -Path $registory_key -Name "Finished Copy") -eq $True ) {

    Set-ItemProperty -Path $registory_key -Name "Finished Backup-HPV" -Value $True -Force | Out-Null
}
else {
    Set-ItemProperty -Path $registory_key -Name "Finished Backup-HPV" -Value $False -Force | Out-Null
}

$finished_backup = Get-ItemPropertyValue -Path $registory_key -Name "Finished Backup-HPV"
## If logging is configured then finish the log file.
If ($LogPath -and $finished_backup) {
    Add-Content -Path $LogFile -Encoding ASCII -Value "$(Get-Date -Format "yyyy-MM-dd HH:mm:ss") [INFO] Log finished"

    ## This whole block is for e-mail, if it is configured.
    If ($SmtpServer) {
        ## Default e-mail subject if none is configured.
        If ($Null -eq $MailSubject) {
            if ($CountError -eq 0) {
                $MailSubject = "[Success]:[$HPV_Host] Backup-VMs Hyper-V Log"
            }
            else {
                $MailSubject = "[Failed]:[$HPV_Host] Backup-VMs Hyper-V Log"
            }
        }

        ## Setting the contents of the log to be the e-mail body.
        $MailBody = Get-Content -Path $LogFile | Out-String

        ## If an smtp password is configured, get the username and password together for authentication.
        ## If an smtp password is not provided then send the e-mail without authentication and obviously no SSL.
        If ($SmtpPwd -and (Test-Path -Path $SmtpPwd)) {

            ## If -ssl switch is used, send the email with SSL.
            ## If it isn't then don't use SSL, but still authenticate with the credentials.
            If ($UseSsl) {
                try {
                    EmailSenden -user $SmtpUser -to $MailTo -from $MailFrom -Subject $MailSubject -Job $Job -Fail $CountError -SSL $UseSsl `
                                -Body $MailBody -LogFile $LogFile -SmtpServer $SmtpServer -SmtpPort $SmtpPort -ErrorAction 'Stop'
                }
                catch {
                    Write-Log -LogFile $LogFile -Type Err -Evt $_.Exception.Message
                }
            }
        }
        else {
            Write-Log -LogFile $LogFile -Type Err -Evt "File with password for email does not exist. Please create"
        }
    }
}

Remove-Variable -Name * -ErrorAction SilentlyContinue

## End