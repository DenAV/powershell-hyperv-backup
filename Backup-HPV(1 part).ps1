<#PSScriptInfo

.VERSION 15.01.2025

.AUTHOR DenAV

#>

<#
    .SYNOPSIS
    Hyper-V Backup Utility - Flexible backup of Hyper-V Virtual Machines.

    .DESCRIPTION
    This script will create a full backup of virtual machines, complete with configuration, snapshots/checkpoints, and VHD files.
    This script should be run on a Hyper-V host and the Hyper-V PowerShell management modules should be installed.

    To send a log file via e-mail using ssl and an SMTP password you must generate an encrypted password file.
    The password file is unique to both the user and machine.
    To create the password file run this command as the user and on the machine that will use the file:

    $creds = Get-Credential
    $creds.Password | ConvertFrom-SecureString | Set-Content c:\foo\ps-script-pwd.txt

    .PARAMETER List
    Enter the path to a txt file with a list of Hyper-V VM names to backup.
    If this option is not configured, all running VMs will be backed up.

    .PARAMETER Wd
    The path to the working directory to use for the backup before copying it to the final backup directory.
    Use a directory on local fast media to improve performance.

    .PARAMETER Keep
    Instructs the utility to keep a specified number of days’ worth of backups.
    VM backups older than the number of days specified will be deleted.
    Every effort has been taken to only remove backup files or folders generated by this utility.

    .PARAMETER Sz
    Configure the utility to use 7-Zip to compress the VM backups.
    7-Zip must be installed in the default location ($env:ProgramFiles) if it is not found, Windows compression will be used as a fallback.
    
    .PARAMETER SzThreads
    Configure 7-Zip to use more threads. mmt1 [1 thread] - mmt8 [8 threads].
    Please note this switch is passed through to 7-Zip. See 7-Zip help for more information.

    .PARAMETER SzComp
    Configure 7-Zip's compression strength. mx1 [fast compression] - mx9 [ultra compression].
    Please note this switch is passed through to 7-Zip. See 7-Zip help for more information.

    .PARAMETER ShortDate
    Configure the script to use only the Year, Month and Day in backup filenames.

    .PARAMETER Subject
    The subject line for the e-mail log. Encapsulate with single or double quotes.
    If no subject is specified, the default of "Hyper-V Backup Utility Log" will be used.

    .PARAMETER SendTo
    The e-mail address the log should be sent to.

    .PARAMETER From
    The e-mail address the log should be sent from.

    .PARAMETER Smtp
    The DNS name or IP address of the SMTP server.

    .PARAMETER User
    The user account to authenticate to the SMTP server.

    .PARAMETER Pwd
    The txt file containing the encrypted password for SMTP authentication.

    .PARAMETER UseSsl
    Configures the utility to connect to the SMTP server using SSL.

    .EXAMPLE
    Hyper-V-Backup.ps1 -BackupTo \\nas\vms -List C:\scripts\vms.txt -Wd E:\temp -NoPerms -Keep 30
    -Compress -Sz -SzThreads mmt8 -SzComp mx5 -L C:\scripts\logs -Subject 'Server: Hyper-V Backup' -SendTo me@contoso.com
    -From hyperv@contoso.com -Smtp smtp.outlook.com -User user -Pwd C:\foo\pwd.txt -UseSsl

    This will shutdown, one at a time, all the VMs listed in the file located in C:\scripts\vms.txt
    and back up their files to \\nas\vms, using E:\temp as a working directory. A zip file for each
    VM folder will be created using 7-zip. 7-zip will use 8 threads and medium compression. Any
    backups older than 30 days will also be deleted. The log file will be output to C:\scripts\logs
    and sent via e-mail with a custom subject line.
#>

## Set up command line switches.
[CmdletBinding()]

Param(
    [Parameter(Mandatory=$False)]
    [alias("Except")] $ExceptList = $Null, # '\Liste\vms_except.txt',
    [Parameter(Mandatory=$False)]
    [alias("VMs")] $VmList = $Null, # '\Liste\vms_list.txt',
    [Parameter(Mandatory=$False)]
    [alias("Disk")] $DiskWorkDir = 'E:\', # $Null, path for Local-Backup
    [Parameter(Mandatory=$False)]
    [alias("L_Keep")] $L_History = 1, # 1 day restore point for Local-Backup
    [Parameter(Mandatory=$False)]
    [alias("R_Keep")] $R_History = 3, # 3 days restore points for Remote-Backup
    [Parameter(Mandatory=$False)]
    [alias("Backup")] $BackupDir = "\\backup.example.com\cloudtest-01\", #$Null,  # Remote-Backup
    [Parameter(Mandatory=$False)]
    [alias("SzThreads")] $SzThreadNo = 'mmt10',
    [Parameter(Mandatory=$False)]
    [alias("SzComp")] $SzCompL = 'mx1',
    [Parameter(Mandatory=$False)] [switch]$ShortDate = $False,
    [Parameter(Mandatory=$False)] [switch]$Encrypt = $True,
    [Parameter(Mandatory=$False)] [switch]$DateTime = $False,
    [Parameter(Mandatory=$False)] [switch]$ConfigFile = $False # Using configuration file
)

$Error.Clear()

# Set the variable for the host name.
$HPV_Host = $Env:ComputerName 

## Set a variable for the path of the script.
$ParentPath = [System.IO.Path]::GetDirectoryName($myInvocation.MyCommand.Definition)

## Import the BackupHPV module with shared functions
$ModulePath = Join-Path -Path $ParentPath -ChildPath "modules\BackupHPV\BackupHPV.psm1"
if (Test-Path $ModulePath) {
    Import-Module $ModulePath -Force
} else {
    Write-Error "BackupHPV module not found at: $ModulePath"
    exit 1
}

if ($ConfigFile) {
    # Get configuration ini
    if (Test-Path (Join-Path -Path $ParentPath -ChildPath "backup-hpv.ini")) {
        
        $conf_ini = (Join-Path -Path $ParentPath -ChildPath "backup-hpv.ini") | Get-IniFile # a function from module ADVModule
    
        $DiskWorkDir = $conf_ini.local.directory
        $BackupDir = $conf_ini.backup.directory
        
        $L_History = $conf_ini.local.history
        $R_History = $conf_ini.backup.history
        
        $VmList = $conf_ini.path.vms_list
        $ExceptList = $conf_ini.path.vms_except
    } else {
        Write-Error "Configuration file backup-hpv.ini not found!"
        exit 1
    }
}

#################################################

# Logging
$LogPath = Join-Path -Path $ParentPath -ChildPath "Logging"

# for Email body
$CountError = 0
$Job = "Backup-HPV (1 part) job: The task of backing up VMs on the $HPV_Host"

# for SMTP server authentication
$SmtpServer = 'mail.example.com'
$SmtpPort = 587
$UseSsl = $True
# Sender
$SmtpUser = 'backup-server@example.com'
# File with encrypted password
$SmtpPwd = Join-Path -Path $ParentPath -ChildPath "pwd-storage.txt"

# Email address
$MailFrom = $SmtpUser
$MailTo = 'monitoring@example.de'
$MailSubject = $Null

# for 7-Zip
$Backup_Day = Get-DateShort

# Path registry key for backup status
$registory_key = "HKLM:\SOFTWARE\Backup-HPV"

## Functions Start-Copy_Daten, Export-StandardRunVM, and Compress-VM
## are provided by the BackupHPV module (modules/BackupHPV/BackupHPV.psm1)

########################################
##          START the Skript          ##
########################################

if (Test-Path $registory_key) {
    # Remove alle Value im HKLM:\SOFTWARE\Backup-HPV
    Get-Item -Path $registory_key | Select-Object -ExpandProperty Property | 
        ForEach-Object -Process { Remove-ItemProperty -Path $registory_key -Name $_}

    # "Date Backup-HPV" - "Datum", Datensicherung
    New-ItemProperty -Path $registory_key -Name "Date Backup-HPV" -Value $Backup_Day -PropertyType String -Force | Out-Null

    ## "Result Backup-HPV(1 part)" - "Running", "Succes" oder "Failure", Waren Fehler mit Export und Sicherung oder nicht.
    New-ItemProperty -Path $registory_key -Name "Result Backup-HPV(1 part)" -Value "new" -PropertyType String -Force | Out-Null
    # "Backup-HPV finished" - "$True" oder "$False", komplett Datensicherung (export, zippen, copy) ist erledigt. 
    New-ItemProperty -Path $registory_key -Name "Finished Backup-HPV" -Value $False -PropertyType String -Force | Out-Null

    ## "Result Export" - "Succes" oder "Failure", Zeigt wie geht es mit Export VM, gibt es Fehler oder nicht.
    New-ItemProperty -Path $registory_key -Name "Result Export" -Value "-" -PropertyType String -Force | Out-Null
    # "Finished Export" - "$True" oder "$False", komplett Export VM ist erledigt.
    New-ItemProperty -Path $registory_key -Name "Finished Export" -Value $False -PropertyType String -Force | Out-Null

    ## "Result Zippen" - "Succes" oder "Failure", Zeigt wie geht es mit Zippen VM, gibt es Fehler oder nicht.
    New-ItemProperty -Path $registory_key -Name "Result Zippen" -Value "-" -PropertyType String -Force | Out-Null
    # "Finished Zippen" - "$True" oder "$False", komplett Zippen VM ist erledigt.
    New-ItemProperty -Path $registory_key -Name "Finished Zippen" -Value $False -PropertyType String -Force | Out-Null

    ## "Result Copy" - "Succes" oder "Failure", Zeigt wie geht es mit Sicherungen für Daten, gibt es Fehler oder nicht.
    New-ItemProperty -Path $registory_key -Name "Result Copy" -Value "-" -PropertyType String -Force | Out-Null
    # "Finished Copy" - "$True" oder "$False", komplett Zippen VM ist erledigt.
    New-ItemProperty -Path $registory_key -Name "Finished Copy" -Value $False -PropertyType String -Force | Out-Null
}
else {
    Write-Error "Path - $($registory_key) does not exist"
    throw
}

## If logging is configured, start logging.
## If the log file already exists, clear it.
if($LogPath) {
    $FileName = "$($Backup_Day) Backup-HPV (1 part).log"
    $LogFile = "$($LogPath)\$($FileName)"
    
    If (-not (Test-Path -Path $LogPath)) {
        New-Item $LogPath -ItemType Directory -Force | Out-Null
        Write-Log -Type Info -Evt "Logging directory $LogFile doesn't exist. Creating it."
    }
    else {
        # Bereinigung alter Logdatei
        try {
            Clear-Log-History -LogPath $LogPath -History $R_History -LogFile $LogFile -ErrorAction 'Stop'
        
            If (Test-Path -Path $LogFile) {
                Clear-Content -Path $LogFile
            } 
        }
        catch {
            $_.Exception.Message | Add-Content -Path $LogFile -Encoding ASCII -Value "$(Get-Date -Format "yyyy-MM-dd HH:mm:ss") [ERROR] $_"
        }
    }
    Add-Content -Path $LogFile -Encoding ASCII -Value "$(Get-Date -Format "yyyy-MM-dd HH:mm:ss") [INFO] Log started"
}
else {
    Write-Warning "Existiert Path for Log-File nicht!"
}

## Set Result Backup-HPV(1 part) = Running

Set-ItemProperty -Path $registory_key -Name "Result Backup-HPV(1 part)" -Value "Running" -Force | Out-Null

# Prüfung Verzeichnis für Local-Backup
if (![System.IO.Directory]::Exists($DiskWorkDir)) {
    Write-Log -LogFile $LogFile -Type Err -Evt "Das Verzeichnis: $DiskWorkDir fuer Local-Backup existiert nicht!"
}
## Verzeichnis existiert
else {
    # Local-Backup Verzeichnis
    ## Set a variable the path the virtual machines should be backed up to.
    if ($DateTime) {
        $WorkDir = "$($DiskWorkDir)\$($Backup_Day)\$(Get-DateTime)"
        $Backup = "$($BackupDir)\$($Backup_Day)\$(Get-DateTime)"
    }
    else {
        $WorkDir = "$($DiskWorkDir)\$($Backup_Day)"
        $Backup = "$($BackupDir)\$($Backup_Day)"
    }

    ##
    ## Display the current config and log if configured.
    ##

    Write-Log -LogFile $LogFile -Type Conf -Evt "************ Running with the following config *************."
    Write-Log -LogFile $LogFile -Type Conf -Evt "This virtual host:.......$HPV_Host."

    ## If a VM list file is configured, get the content of the file.
    ## If a VM list file is not configured, just get the running VMs.
    if ($VmList -and (Get-Content $VmList)) {
        $CheckVM = Get-Content $VmList
    }
    else {
        $CheckVM = Get-VM | Where-Object {$_.State -eq "Running"} | Select-Object -ExpandProperty Name
    }
    ## If a VM exception list file is configured, get the content of the file.
    if ($ExceptList -and (Get-Content $ExceptList)) {

        Write-Log -LogFile $LogFile  -Type Conf -Evt "VMs liegt im Ausnahme-Datei ..."
        if ($CheckVM) {
            $Vms = [System.Collections.ArrayList]::new()
            $CheckVM | ForEach-Object {
                # Suchen VM in Ausnahmen
                $ausnamen_vm = (Get-Content $ExceptList).Contains($_)

                if ($ausnamen_vm) {
                    Write-Log -LogFile $LogFile  -Type Conf -Evt "...............$($_)"
                } 
                else { 
                    [void]$Vms.Add($_) 
                }
            }        
        }
        else {
            Write-Log -LogFile $LogFile -Type Info -Evt "... Alle VMs sind ausgeschaltet"
        }
        
    } # END If ($ExceptList -and (Get-Content $ExceptList))
    else {
        $Vms = $CheckVM
    }

    ## Check to see if there are any running VMs.
    ## If there are no VMs, then do nothing.
    If ($Vms.count -ne 0) {
        ## If the user has not configured the working directory, set it as the backup directory.
        If ($Null -eq $SzThreadNo) {
            $SzThreadNo = "mmt1"
        }

        If ($Null -eq $SzCompL) {
            $SzCompL = "mx1"
        }

        Write-Log -LogFile $LogFile -Type Conf -Evt "VMs to backup:...........: $($Vms.Count)"
        
        $Vms | ForEach-Object {
            Write-Log -LogFile $LogFile -Type Conf -Evt ".........................$_"
        }

        Write-Log -LogFile $LogFile -Type Conf -Evt "Remote-Backup directory:........$Backup."
        Write-Log -LogFile $LogFile -Type Conf -Evt "Local-Working directory:.......$WorkDir."
    
        If ($Null -ne $L_History) { Write-Log -LogFile $LogFile -Type Conf -Evt "Local Backups to keep:.........$L_History days" }
        else { Write-Log -LogFile $LogFile -Type Conf -Evt "Local Backups to keep:.........No Config" }
        
        If ($Null -ne $R_History) { Write-Log -LogFile $LogFile -Type Conf -Evt "Remote Backups to keep:.........$R_History days" }
        else { Write-Log -LogFile $LogFile -Type Conf -Evt "Remote Backups to keep:.........No Config" }

        If ($Null -ne $LogPath) { Write-Log -LogFile $LogFile -Type Conf -Evt "Logs directory:..........$LogPath." }
        else { Write-Log -LogFile $LogFile -Type Conf -Evt "Logs directory:..........No Config" }
    
        If ($MailTo) { Write-Log -LogFile $LogFile -Type Conf -Evt "E-mail log to:...........$MailTo." }
        else { Write-Log -LogFile $LogFile -Type Conf -Evt "E-mail log to:...........No Config" }
    
        If ($MailFrom) { Write-Log -LogFile $LogFile -Type Conf -Evt "E-mail log from:.........$MailFrom." }
        else { Write-Log -LogFile $LogFile -Type Conf -Evt "E-mail log from:.........No Config" }
    
        If ($SmtpServer) { Write-Log -LogFile $LogFile -Type Conf -Evt "SMTP server:.............$SmtpServer." }
        else { Write-Log -LogFile $LogFile -Type Conf -Evt "SMTP server:.............No Config" }

        If ($SmtpPwd) { Write-Log -LogFile $LogFile -Type Conf -Evt "SMTP pwd file:...........$SmtpPwd." }
        else { Write-Log -LogFile $LogFile -Type Conf -Evt "SMTP pwd file:...........No Config" }

        Write-Log -LogFile $LogFile -Type Conf -Evt "7-zip threads:...........$SzThreadNo."
        Write-Log -LogFile $LogFile -Type Conf -Evt "7-zip compression:.......$SzCompL."
        Write-Log -LogFile $LogFile -Type Conf -Evt "**************************************************************"
        Write-Log -LogFile $LogFile -Type Info -Evt "Process started."
        ##
        ## Display current config ends here.
        ##
    
        #    
        ## delete old backup data
        #
        try {
            Remove-OldDate -DirPath $DiskWorkDir -keep $L_History -LogFile $LogFile -ErrorAction 'Stop'
        }
        catch{
            Write-Log -LogFile $LogFile -Type Err -Evt $_.Exception.Message
        }
    
        ##
        ## Standard export process starts here.
        ##

        ## If the -NoPerms switch is NOT set, for each VM check for the existence of a previous export.
        ## If it exists then delete it, otherwise the export will fail.
        #
        $Vms | Get-VM | Where-Object {$_.State -eq "Running"} | Select-Object -ExpandProperty Name | Foreach-Object {
            $count_export = 0
            do {
                try {
                    ## Run Export
                    Set-ItemProperty -Path $registory_key -Name "Finished Export" -Value $False -Force | Out-Null

                    Export-StandardRunVM -ExportVmName $_ -ExportDirectory $WorkDir -LogFile $LogFile -RegistryKey $registory_key
                    
                    if((Get-ItemPropertyValue -Path $registory_key -Name "Result Export") -ne "Success" ) {
                        $count_export += 1
                        Write-Log -LogFile $LogFile -Type Err -Evt "Attempting to export VM:$count_export, Sleep 10"
                        Start-Sleep 10
                    }
                }
                catch {
                    Write-Log -LogFile $LogFile -Type Err -Evt "Attempting to export VM:$count_export, $($_.Exception.Message)"
                    $count_export += 1
                    Start-Sleep 10
                }
            # Condition that stops the loop if it returns true
            } until ( (Get-ItemPropertyValue -Path $registory_key -Name "Result Export" -ErrorAction Ignore) -eq "Success" `
                    -or $count_export -ge 3)
                
            try {
                ## Run Zippen VM.
                Set-ItemProperty -Path $registory_key -Name "Finished Zippen" -Value $False -Force | Out-Null
                Compress-VM -VmName $_ -WorkDir $WorkDir -LogFile $LogFile -RegistryKey $registory_key `
                           -SzThreads $SzThreadNo -SzCompression $SzCompL -ShortDate:$ShortDate `
                           -Encrypt:$Encrypt -EncryptionPwdFile $SmtpPwd
            }
            catch {
                Write-Log -LogFile $LogFile -Type Err -Evt $_.Exception.Message
                Set-ItemProperty -Path $registory_key -Name "Result Zippen" -Value "Failure" -Force | Out-Null
            }

        }
        
        Set-ItemProperty -Path $registory_key -Name "Finished Export" -Value $True -Force | Out-Null
        Set-ItemProperty -Path $registory_key -Name "Finished Zippen" -Value $True -Force | Out-Null
        
    } # If ($Vms.count -ne 0)

    ## If there are no VMs running, then do nothing.
    else {
        Write-Log -LogFile $LogFile -Type Info -Evt "There are no VMs running to backup"
    }
} ## END Else: Verzeichnis existiert

Write-Log -LogFile $LogFile -Type Info -Evt "Process finished. Fehler waren: $CountError"

## "Result Backup-HPV(1 part)" ist "Success" oder "Failure"
if ((Get-ItemPropertyValue -Path $registory_key -Name "Result Export") -eq "Success" `
    -and (Get-ItemPropertyValue -Path $registory_key -Name "Result Zippen") -eq "Success" `
    -and (Get-ItemPropertyValue -Path $registory_key -Name "Finished Export") -eq $True `
    -and (Get-ItemPropertyValue -Path $registory_key -Name "Finished Zippen") -eq $True `
    -and $CountError -le 0) {

    Set-ItemProperty -Path $registory_key -Name "Result Backup-HPV(1 part)" -Value "Success" -Force | Out-Null
}
else {
    Set-ItemProperty -Path $registory_key -Name "Result Backup-HPV(1 part)" -Value "Failure" -Force | Out-Null
}
## If logging is configured then finish the log file.
If ($LogPath) {
    Add-Content -Path $LogFile -Encoding ASCII -Value "$(Get-Date -Format "yyyy-MM-dd HH:mm:ss") [INFO] Log finished"

    ## This whole block is for e-mail, if it is configured.
    If ($SmtpServer) {
        ## Default e-mail subject if none is configured.
        If ($Null -eq $MailSubject) {
            if ($CountError -eq 0) {
                $MailSubject = "[Success]:[$HPV_Host] Backup-VMs Hyper-V Log"
            }
            else {
                $MailSubject = "[Failed]:[$HPV_Host] Backup-VMs Hyper-V Log"
            }
        }

        ## Setting the contents of the log to be the e-mail body.
        $MailBody = Get-Content -Path $LogFile | Out-String

        ## If an smtp password is configured, get the username and password together for authentication.
        ## If an smtp password is not provided then send the e-mail without authentication and obviously no SSL.
        If ($SmtpPwd -and (Test-Path -Path $SmtpPwd)) {

            ## If -ssl switch is used, send the email with SSL.
            ## If it isn't then don't use SSL, but still authenticate with the credentials.
            If ($UseSsl) {
                try {
                    EmailSenden -user $SmtpUser -to $MailTo -from $MailFrom -Subject $MailSubject -Job $Job -Fail $CountError -SSL $UseSsl `
                                -Body $MailBody -LogFile $LogFile -SmtpServer $SmtpServer -SmtpPort $SmtpPort -ErrorAction 'Stop'
                }
                catch {
                    Write-Log -LogFile $LogFile -Type Err -Evt $_.Exception.Message
                }
            }
        }
        else {
            Write-Log -LogFile $LogFile -Type Err -Evt "File with password for email does not exist. Please create"
        }
    }
}

Remove-Variable -Name * -ErrorAction SilentlyContinue

## End