<#PSScriptInfo

.VERSION 15.06.2022

.AUTHOR Denis Denk

#>

<#
    .SYNOPSIS
    Hyper-V Backup Utility - Flexible backup of Hyper-V Virtual Machines.

    .DESCRIPTION
    This script will create a full backup of virtual machines, complete with configuration, snapshots/checkpoints, and VHD files.
    This script should be run on a Hyper-V host and the Hyper-V PowerShell management modules should be installed.

    To send a log file via e-mail using ssl and an SMTP password you must generate an encrypted password file.
    The password file is unique to both the user and machine.
    To create the password file run this command as the user and on the machine that will use the file:

    $creds = Get-Credential
    $creds.Password | ConvertFrom-SecureString | Set-Content c:\foo\ps-script-pwd.txt

    .PARAMETER List
    Enter the path to a txt file with a list of Hyper-V VM names to backup.
    If this option is not configured, all running VMs will be backed up.

    .PARAMETER Wd
    The path to the working directory to use for the backup before copying it to the final backup directory.
    Use a directory on local fast media to improve performance.

    .PARAMETER Keep
    Instructs the utility to keep a specified number of days’ worth of backups.
    VM backups older than the number of days specified will be deleted.
    Every effort has been taken to only remove backup files or folders generated by this utility.

    .PARAMETER Sz
    Configure the utility to use 7-Zip to compress the VM backups.
    7-Zip must be installed in the default location ($env:ProgramFiles) if it is not found, Windows compression will be used as a fallback.
    
    .PARAMETER SzThreads
    Configure 7-Zip to use more threads. mmt1 [1 thread] - mmt8 [8 threads].
    Please note this switch is passed through to 7-Zip. See 7-Zip help for more information.

    .PARAMETER SzComp
    Configure 7-Zip's compression strength. mx1 [fast compression] - mx9 [ultra compression].
    Please note this switch is passed through to 7-Zip. See 7-Zip help for more information.

    .PARAMETER ShortDate
    Configure the script to use only the Year, Month and Day in backup filenames.

    .PARAMETER Subject
    The subject line for the e-mail log. Encapsulate with single or double quotes.
    If no subject is specified, the default of "Hyper-V Backup Utility Log" will be used.

    .PARAMETER SendTo
    The e-mail address the log should be sent to.

    .PARAMETER From
    The e-mail address the log should be sent from.

    .PARAMETER Smtp
    The DNS name or IP address of the SMTP server.

    .PARAMETER User
    The user account to authenticate to the SMTP server.

    .PARAMETER Pwd
    The txt file containing the encrypted password for SMTP authentication.

    .PARAMETER UseSsl
    Configures the utility to connect to the SMTP server using SSL.

    .EXAMPLE
    Hyper-V-Backup.ps1 -BackupTo \\nas\vms -List C:\scripts\vms.txt -Wd E:\temp -NoPerms -Keep 30
    -Compress -Sz -SzThreads mmt8 -SzComp mx5 -L C:\scripts\logs -Subject 'Server: Hyper-V Backup' -SendTo me@contoso.com
    -From hyperv@contoso.com -Smtp smtp.outlook.com -User user -Pwd C:\foo\pwd.txt -UseSsl

    This will shutdown, one at a time, all the VMs listed in the file located in C:\scripts\vms.txt
    and back up their files to \\nas\vms, using E:\temp as a working directory. A zip file for each
    VM folder will be created using 7-zip. 7-zip will use 8 threads and medium compression. Any
    backups older than 30 days will also be deleted. The log file will be output to C:\scripts\logs
    and sent via e-mail with a custom subject line.
#>

## Set up command line switches.
[CmdletBinding()]

Param(
    [alias("Except")] $ExceptList = 'C:\Scripts\HyperV-Backup\Liste\vms_except.txt',
    [alias("VMs")] $VmList = $Null,  # \Liste\vms_0.txt
    [alias("Disk")] $DiskWorkDir = 'E:\', # $Null, path for Local-Backup
    [alias("L_Keep")] $L_History = 1, # 1 Tagen für Local-Backup
    [alias("R_Keep")] $R_History = 3, # 1 Tagen für RemoteBackup
    [alias("Backup")] $BackupDir = "\\backup.example.com\cloudtest-01\", #$Null,  # Remote-Backup
    [alias("SzThreads")] $SzThreadNo = 'mmt10',
    [alias("SzComp")] $SzCompL = 'mx1',
    [switch]$ShortDate,
    [switch]$Encrypt = $True,
    [switch]$DateTime = $False)

$Error.Clear()

## Set a variable for computer name of the Hyper-V server. Vs
$HPV_Host = $Env:ComputerName 

# Ordner, in dem das Script liegt ermitteln
$scriptFolder = [System.IO.Path]::GetDirectoryName($myInvocation.MyCommand.Definition)
$path = $scriptFolder

## Import the BackupHPV module with shared functions
$ModulePath = Join-Path -Path $path -ChildPath "modules\BackupHPV\BackupHPV.psm1"
if (Test-Path $ModulePath) {
    Import-Module $ModulePath -Force
} else {
    Write-Error "BackupHPV module not found at: $ModulePath"
    exit 1
}

# Get Konfiguration
if (Test-Path "$($path)\backup-hpv.ini") {
    
    $conf_ini = "$($path)\backup-hpv.ini" | Get-IniFile

    $DiskWorkDir = $conf_ini.local.directory
    $BackupDir = $conf_ini.backup.directory
    
    $L_History = $conf_ini.local.history
    $R_History = $conf_ini.backup.history
}
#################################################

# Logging
$LogPath = "$path\Logging"

# Für Email Body
$CountError = 0
$Job = "Backup-HPV (2 part) job: Die Aufgabe, sichern VMs auf dem $HPV_Host"

# für SMTP-Server authentication
$SmtpServer = 'mail.example.com'
$SmtpPort = 587
$UseSsl = $True
# Auth Absender
$SmtpUser = 'backup-server@example.com'
$SmtpPwd = "$path\pwd-storage.txt"

# Mail-Adresse
$MailFrom = $SmtpUser
$MailTo = 'monitoring@example.de'
$MailSubject = $Null

# Registry key
$registory_key = "HKLM:\SOFTWARE\Backup-HPV"

## Function Start-Copy_Daten is provided by the BackupHPV module
## (modules/BackupHPV/BackupHPV.psm1)

########################################
##          START the Skript          ##
########################################

# Get regisrory variable
if (Test-Path $registory_key) {

    if (Test-RegistryValue -regkey $registory_key -value "Date Backup-HPV") {
        ## Get a Registry key "Date Backup-HPV" - "Datum", Datensicherung
        $Backup_Day = Get-ItemPropertyValue -Path $registory_key -Name "Date Backup-HPV"
    }

    if (Test-RegistryValue -regkey $registory_key -value "Finished Copy") {
        $finished_copy = Get-ItemPropertyValue -Path $registory_key -Name "Finished Copy"
    }

    if (Test-RegistryValue -regkey $registory_key -value "Result Zippen") {
        $result_zippen = Get-ItemPropertyValue -Path $registory_key -Name "Result Zippen"
    }

    # Set Result Backup-HPV(2 part) für Anfang.
    if ((Test-RegistryValue -regkey $registory_key -value "Result Backup-HPV(2 part)") -eq $False -and $finished_copy -eq $False) {
        ## "Result Backup-HPV(2 part)" - "Running", "Succes" oder "Failure", Waren Fehler mit Export und Sicherung oder nicht.
        New-ItemProperty -Path $registory_key -Name "Result Backup-HPV(2 part)" -Value "new" -PropertyType String -Force | Out-Null
    }
}
else {
    Write-Error "Existiert Path - HKLM:\SOFTWARE\Backup-HPV nicht"
    break
}

## If logging is configured, start logging.
## If the log file already exists, clear it.
if (Test-RegistryValue -regkey $registory_key -value "Result Backup-HPV(2 part)") {
    $result_backup_hpv = Get-ItemPropertyValue -Path $registory_key -Name "Result Backup-HPV(2 part)"
}

if (($result_zippen -eq "Success" -or $result_zippen -eq "Running") -and ($finished_copy -ne $True) -and $Backup_Day) {

    if ($LogPath) {
        $FileName = "$($Backup_Day) Backup-HPV (2 part).log"
        $LogFile = "$($LogPath)\$($FileName)"
        
        if (-not (Test-Path -Path $LogPath)) {
            New-Item $LogPath -ItemType Directory -Force | Out-Null
            Write-Log -Type Info -Evt "Logging directory $LogFile doesn't exist. Creating it."
        }
    }

    If ($LogPath -and $finished_copy -eq $False -and $result_backup_hpv -eq "new") {
        
        try {
            Clear-Log-History -LogPath $LogPath -History $R_History -LogFile $LogFile -ErrorAction 'Stop'
        }
        catch {
            $_.Exception.Message | Add-Content -Path $LogFile -Encoding ASCII -Value "$(Get-Date -Format "yyyy-MM-dd HH:mm:ss") [ERROR] $_"

        }

        If (Test-Path -Path $LogFile) {
            Clear-Content -Path $LogFile
        } 

        Add-Content -Path $LogFile -Encoding ASCII -Value "$(Get-Date -Format "yyyy-MM-dd HH:mm:ss") [INFO] Log started"
    }

    #
    # Prüfung Verzeichnis für Local-Backup
    if (![System.IO.Directory]::Exists($DiskWorkDir)) {
        Write-Log -LogFile $LogFile -Type Err -Evt "Das Verzeichnis: $DiskWorkDir fuer Local-Backup existiert nicht!"
    }
    ## Verzeichnis existiert
    else {
        # Local-Backup Verzeichnis
        ## Set a variable the path the virtual machines should be backed up to.
        if ($DateTime) {
            $WorkDir = "$($DiskWorkDir)\$($Backup_Day)\$(Get-DateTime)"
            $Backup = "$($BackupDir)\$($Backup_Day)\$(Get-DateTime)"
        }
        else {
            $WorkDir = "$($DiskWorkDir)\$($Backup_Day)"
            $Backup = "$($BackupDir)\$($Backup_Day)"
        }

        if ($result_backup_hpv -eq "new") {

            Set-ItemProperty -Path $registory_key -Name "Result Backup-HPV(2 part)" -Value "Running" -Force | Out-Null
            ##
            ## Display the current config and log if configured.
            ##
                
            Write-Log -LogFile $LogFile -Type Conf -Evt "************ Running with the following config *************."
            Write-Log -LogFile $LogFile -Type Conf -Evt "This virtual host:.......$HPV_Host."

            ## Check to see if there are any running VMs.
            ## If there are no VMs, then do nothing.

            Write-Log -LogFile $LogFile -Type Conf -Evt "Remote-Backup directory:........$Backup."
            Write-Log -LogFile $LogFile -Type Conf -Evt "Local-Working directory:.......$WorkDir."
        
            If ($Null -ne $R_History) { Write-Log -LogFile $LogFile -Type Conf -Evt "Remote Backups to keep:.........$R_History days" }
            else { Write-Log -LogFile $LogFile -Type Conf -Evt "Remote Backups to keep:.........No Config" }

            If ($Null -ne $LogPath) { Write-Log -LogFile $LogFile -Type Conf -Evt "Logs directory:..........$LogPath." }
            else { Write-Log -LogFile $LogFile -Type Conf -Evt "Logs directory:..........No Config" }
        
            If ($MailTo) { Write-Log -LogFile $LogFile -Type Conf -Evt "E-mail log to:...........$MailTo." }
            else { Write-Log -LogFile $LogFile -Type Conf -Evt "E-mail log to:...........No Config" }
        
            If ($MailFrom) { Write-Log -LogFile $LogFile -Type Conf -Evt "E-mail log from:.........$MailFrom." }
            else { Write-Log -LogFile $LogFile -Type Conf -Evt "E-mail log from:.........No Config" }
        
            If ($SmtpServer) { Write-Log -LogFile $LogFile -Type Conf -Evt "SMTP server:.............$SmtpServer." }
            else { Write-Log -LogFile $LogFile -Type Conf -Evt "SMTP server:.............No Config" }

            If ($SmtpPwd) { Write-Log -LogFile $LogFile -Type Conf -Evt "SMTP pwd file:...........$SmtpPwd." }
            else { Write-Log -LogFile $LogFile -Type Conf -Evt "SMTP pwd file:...........No Config" }

            Write-Log -LogFile $LogFile -Type Conf -Evt "-Sz switch:..............$Sz."
            Write-Log -LogFile $LogFile -Type Conf -Evt "7-zip threads:...........$SzThreadNo."
            Write-Log -LogFile $LogFile -Type Conf -Evt "7-zip compression:.......$SzCompL."
            Write-Log -LogFile $LogFile -Type Conf -Evt "**************************************************************"
            Write-Log -LogFile $LogFile -Type Info -Evt "Process started."
            
            Write-Log -LogFile $LogFile -Type Info -Evt "Datensicherung fuer $WorkDir gestartet."
            
            ##
            ## END Display current config.
            ##

        } # END IF ($result_backup_hpv -ne "Running")

        ##
        ## Copy process starts here.
        ##
        
        if ([System.IO.Directory]::Exists($BackupDir)){
            if ([System.IO.Directory]::Exists($WorkDir)){
                $count_copy = 0
                do {
                    try {
                        ## Run the Copy
                        Set-ItemProperty -Path $registory_key -Name "Finished Copy" -Value $False -Force | Out-Null
                        
                        Start-Copy_Daten -sourceDirPath $WorkDir -destDirPath $Backup `
                                         -LogFile $LogFile -RegistryKey $registory_key `
                                         -UpdatePipelineStatus -ErrorAction 'Stop'
                        if((Get-ItemPropertyValue -Path $registory_key -Name "Result Copy") -ne "Success" ) {
                            Write-Log -LogFile $LogFile -Type Err -Evt "Attempting to copy VM:$count_copy, Sleep 30"
                            $count_copy += 1
                            Start-Sleep 30
                        }
                    }
                    catch {
                        Write-Log -LogFile $LogFile -Type Err -Evt "Attempting to copy VM:$count_copy, $($_.Exception.Message), Sleep 30"
                        $count_copy += 1
                        Start-Sleep 30
                    }
                    # Condition that stops the loop if it returns true
                } until ( (Get-ItemPropertyValue -Path $registory_key -Name "Result Copy") -eq "Success" `
                        -or $count_copy -ge 3)
            }
            else {
                Write-Log -LogFile $LogFile -Type Err -Evt "Das Verzeichnis Lokale-Backup ist nicht erreichbar: $WorkDir"
            }
        }
        else {
            Write-Log -LogFile $LogFile -Type Err -Evt "Das Verzeichnis Remote-Backup ist nicht erreichbar: $BackupDir"
        }

    } ## END Else: Verzeichnis existiert
    
    # Suchen Error in der Log-Datei
    $CountError_LogFile = Select-String -Path $LogFile -SimpleMatch "[ERROR]"
    
    # TODO prüfen (neue Version ab 29.08.2022)
    ## "Result Backup-HPV(2 part)" ist "Success" oder "Failure"
    if ((Get-ItemPropertyValue -Path $registory_key -Name "Finished Copy") -eq $True ) {

        if((Get-ItemPropertyValue -Path $registory_key -Name "Result Copy") -eq "Success" `
            -and $CountError_LogFile.Count -le 0){

            Set-ItemProperty -Path $registory_key -Name "Result Backup-HPV(2 part)" -Value "Success" -Force | Out-Null
            Write-Log -LogFile $LogFile -Type Info -Evt "Ordner: $WorkDir wurde erfolgreich gesichert."
        }
        else {
            Set-ItemProperty -Path $registory_key -Name "Result Backup-HPV(2 part)" -Value "Failure" -Force | Out-Null
            Write-Log -LogFile $LogFile -Type Err -Evt "Ordner: $WorkDir wurde mit Fehler gesichert!"
        }

    }

    ## "Finished Backup-HPV" ist "Success" oder "Failure"
    if ((Get-ItemPropertyValue -Path $registory_key -Name "Finished Export") -eq $True `
        -and (Get-ItemPropertyValue -Path $registory_key -Name "Finished Zippen") -eq $True `
        -and (Get-ItemPropertyValue -Path $registory_key -Name "Finished Copy") -eq $True ) {

        Set-ItemProperty -Path $registory_key -Name "Finished Backup-HPV" -Value $True -Force | Out-Null
    }
    else {
        Set-ItemProperty -Path $registory_key -Name "Finished Backup-HPV" -Value $False -Force | Out-Null
    }

    $finished_backup = Get-ItemPropertyValue -Path $registory_key -Name "Finished Backup-HPV"

    ## If logging is configured then finish the log file.
    If ($LogPath -and $finished_backup -eq $True) {
        
        ## delete old remote-backup data
        #
        try {
            Remove-OldDate -DirPath $BackupDir -keep $R_History -LogFile $LogFile -ErrorAction 'Stop'
        }
        catch{
            Write-Log -LogFile $LogFile -Type Err -Evt $_.Exception.Message
        } # END delete old remote-backup data

        Add-Content -Path $LogFile -Encoding ASCII -Value "$(Get-Date -Format "yyyy-MM-dd HH:mm:ss") [INFO] Log finished"
        
        Write-Log -LogFile $LogFile -Type Info -Evt "Process finished. Fehler waren: $CountError"
        
        ## This whole block is for e-mail, if it is configured.
        If ($SmtpServer) {
            ## Default e-mail subject if none is configured.
            If ($Null -eq $MailSubject) {
                if ($CountError_LogFile.Count -eq 0) {
                    $MailSubject = "[Success]:[$HPV_Host] Backup-VMs Hyper-V Log"
                }
                else {
                    $MailSubject = "[Failed]:[$HPV_Host] Backup-VMs Hyper-V Log"
                }
            }

            ## Setting the contents of the log to be the e-mail body.
            $MailBody = Get-Content -Path $LogFile | Out-String

            ## If an smtp password is configured, get the username and password together for authentication.
            ## If an smtp password is not provided then send the e-mail without authentication and obviously no SSL.
            If ($SmtpPwd -and (Test-Path -Path $SmtpPwd)) {

                ## If -ssl switch is used, send the email with SSL.
                ## If it isn't then don't use SSL, but still authenticate with the credentials.
                If ($UseSsl) {
                    try {
                        EmailSenden -user $SmtpUser -to $MailTo -from $MailFrom -Subject $MailSubject -Job $Job -Fail $CountError_LogFile.Count -SSL $UseSsl `
                                    -Body $MailBody -LogFile $LogFile -SmtpServer $SmtpServer -SmtpPort $SmtpPort -ErrorAction 'Stop'
                    }
                    catch {
                        Write-Log -LogFile $LogFile -Type Err -Evt $_.Exception.Message
                    }
                }
            }
            else {
                Write-Log -LogFile $LogFile -Type Err -Evt "File with password for email does not exist. Please create"
            }
        }
    }
}
Remove-Variable -Name * -ErrorAction SilentlyContinue

## End